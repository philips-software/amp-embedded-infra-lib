<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SESAME (SErial Secure Adaptable Message Exchange) :: Embedded Infrastructure Library</title>
    <link rel="canonical" href="https://philips-software.github.io/amp-embedded-infra-lib/embedded_infrastructure_library/7.1.0/Sesame.html">
    <meta name="generator" content="Antora 3.1.9">
    <link rel="stylesheet" href="../../_/css/centralesans.css">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/site-extra.css">
    <link rel="icon" href="../../favicon.svg" type="image/svg+xml">

    <link rel="stylesheet" href="../../_/css/site-extra.css">
    <link rel="stylesheet" href="../../_/css/centralesans.css">

      </head>
  <body class="article">
<header class="header" role="banner">
    <div class="header-top-row">
        <div class="container">
            <nav class="navbar">
                <div class="navbar-brand">
                    <a class="navbar-brand">
                        <img class="scale-down"  src="../../philips-logo.png" alt="Philips"/>
                    </a>
                    <a class="navbar-item" href="https://philips-software.github.io/amp-embedded-infra-lib">Embedded Infrastructure Library</a>
                    <button class="navbar-burger" data-target="topbar-nav">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                </div>
                <div id="topbar-nav" class="navbar-menu">
                    <div class="navbar-end">
                        <a class="navbar-item" href="https://github.com/philips-software/amp-embedded-infra-lib">
                            <span class="icon">
                                <svg aria-labelledby="simpleicons-github-icon" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                <title id="simpleicons-github-icon">GitHub</title>
                                <path fill="#f5f5f5" d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
                            </span>
                        </a>
                    </div>
                </div>
            </nav>
        </div>
    </div>
</header>
<div class="body">
<main class="article">
<div class="toolbar toolbar-wrap">
  <div class="toolbar" role="navigation">
  <button class="nav-toggle"></button>
    <a href="index.html" class="home-link"></a>
  <nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Embedded Infrastructure Library documentation</a></li>
    <li><a href="Sesame.html">Sesame</a></li>
  </ul>
</nav>
      <div class="edit-this-page"><a href="https://github.com/philips-software/amp-embedded-infra-lib/edit/main/documents/modules/ROOT/pages/Sesame.adoc">Edit this page</a></div>
      </div>
</div>
  <div class="content">
<div class="nav-container" data-component="embedded_infrastructure_library" data-version="7.1.0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="index.html">Embedded Infrastructure Library documentation</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="ExecutionModel.html">Execution Model</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="MemoryRange.html">MemoryRange</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Containers.html">Containers</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Echo.html">Echo</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="Sesame.html">Sesame</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="NetworkConnections.html">NetworkConnections</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="CodingStandard.html">Coding Standard</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div></div>
    </div>
  </aside>
</div>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">SESAME (SErial Secure Adaptable Message Exchange)</h1>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Microcontrollers often communicate with each other using a UART connection.
Before such a serial connection can be used by the <a href="Echo.html" class="xref page">ECHO</a> protocol,
a mechanism is needed to initialize communication and prevent overflowing buffers
on the peer. Furthermore, a means to secure the communication is required.
For these purposes the SESAME protocol stack is developed.</p>
</div>
<div class="paragraph">
<p>SESAME consists of several layers, first using <a href="https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing">COBS</a> (Consistent Overhead Byte Stuffing)
to divide the stream of bytes into delimited packets,
second a window protocol to prevent overflowing buffers,
and third (optional) a layer that provides security.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/diag-ae642e19bd4f05f10c73b52619f523635545c7f5.svg" alt="Diagram">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sesame_layer_cobs"><a class="anchor" href="#_sesame_layer_cobs"></a>SESAME layer COBS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The first layer divides the stream of bytes of the serial communication
into a number of packets. The purpose of this is to present well-defined packets to higher
layers in the SESAME stack, where those higher layers can then define packet formats.</p>
</div>
<div class="paragraph">
<p>As specified by the <a href="https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing">COBS</a>
protocol, packets are separated by 0 bytes. This means that any 0 bytes inside the payload must be
replaced. This is done by adding a first byte to the payload, which points to the first 0 byte in
the payload. That 0 byte is then replaced by the index of the next 0 byte, etc. If no 0 byte is
present within 254 bytes is present then an extra overhead byte is inserted. Please see
the <a href="https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing">COBS</a> specification
for details.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sesame_layer_windowed"><a class="anchor" href="#_sesame_layer_windowed"></a>SESAME layer Windowed</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Using the Windowed layer, both sides of the communication notify and update their peer of
available window size. A peer can only send packets up to the available window. Four
packet types are defined:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Init</p>
</li>
<li>
<p>InitResponse</p>
</li>
<li>
<p>ReleaseWindow</p>
</li>
<li>
<p>Message</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_init"><a class="anchor" href="#_init"></a>Init</h3>
<div class="paragraph">
<p>Sending an <code>Init</code> packet initializes the protocol. An <code>Init</code> packet has one 16-bit unsigned parameter <code>size</code>
which specifies the available window size, encoded in little endian order. An <code>Init</code> packet must be responded to with an <code>InitResponse</code>
packet. Before receiving an <code>InitResponse</code>, a peer must assume that no window is available, so
further packets may not be sent.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/diag-af6b8f6d3d484374fcb8f52f4518e36cbd856da4.svg" alt="Init packet">
</div>
<div class="title">Figure 1. Init packet</div>
</div>
<div class="paragraph">
<p>An <code>Init</code> packet consumes no window, and may always be sent. This results in an edge case that an
<code>Init</code> packet sent at an inconvenient moment may overflow the peer&#8217;s buffer. In that case, that
overflow must result in the peer sending an <code>Init</code> packet of its own, and the peer must conclude that
an <code>Init</code> packet has been received; it can then respond with an <code>Init</code> packet of its own, advertising
its available window, and then reading the peer&#8217;s window size from its <code>InitResponse</code> packet. This way,
the data lost in the overflown <code>Init</code> packet is retrieved. Since a sender
has an empty buffer before sending an <code>Init</code> packet, that will not result in a repeated exchange of
<code>Init</code> packets.</p>
</div>
</div>
<div class="sect2">
<h3 id="_initresponse"><a class="anchor" href="#_initresponse"></a>InitResponse</h3>
<div class="paragraph">
<p>When an <code>Init</code> packet has been received, a host will clear its buffer, and advertise available buffer
space using the <code>InitResponse</code> packet. Similar to the <code>Init</code> packet, the <code>InitResponse</code> packet
has one 16-bit unsigned parameter <code>size</code> encoded in little endian which advertises available buffer size.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/diag-4a7611f0d08d0dbc679a6b536923367f5320c5bc.svg" alt="InitResponse packet">
</div>
<div class="title">Figure 2. InitResponse packet</div>
</div>
<div class="paragraph">
<p>An <code>InitResponse</code> packet consumes 5 window bytes: 3 for the packet contents, 2 for the
COBS layer (1 for the COBS overhead byte, one for the terminating 0).</p>
</div>
</div>
<div class="sect2">
<h3 id="_releasewindow"><a class="anchor" href="#_releasewindow"></a>ReleaseWindow</h3>
<div class="paragraph">
<p>When a host has processed incoming packets, and therefore frees up buffer space,
it advertises the freed up space using the <code>ReleaseWindow</code> packet. The <code>ReleaseWindow</code> packet
has one 16-bit unsigned parameter <code>size</code> encoded in little endian which specifies the amount of bytes in the buffer
freed up in addition to already known free space.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/diag-c284003e0e9883d57f06dc12da3de88d15d8519e.svg" alt="ReleaseWindow packet">
</div>
<div class="title">Figure 3. ReleaseWindow packet</div>
</div>
</div>
<div class="sect2">
<h3 id="_message"><a class="anchor" href="#_message"></a>Message</h3>
<div class="paragraph">
<p>Data sent by higher protocol layers are sent by <code>Message</code> packets. Each <code>Message</code> packet consumes a window
amount equal to the size of that packet plus the COBS overhead of that specific packet, plus
its terminating 0.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/diag-44a7e6fea768804d3b097dc66093dfeaa0e0b109.svg" alt="Message packet">
</div>
<div class="title">Figure 4. Message packet</div>
</div>
</div>
<div class="sect2">
<h3 id="_quality_of_implementation"><a class="anchor" href="#_quality_of_implementation"></a>Quality Of Implementation</h3>
<div class="paragraph">
<p>When implementing the Window layer, there are a few considerations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In order to avoid continuous exchanges of <code>ReleaseWindow</code> packets, hosts should only release
window sizes bigger than 5. When determining the buffer size needed to exchange packets, the
size of the biggest packet should be increased by 5 to accommodate for a <code>ReleaseWindow</code> packet.</p>
</li>
<li>
<p>A sender should only send a message when enough window remains to also send a a <code>ReleaseWindow</code>
packet. Otherwise, if both peers consume each other&#8217;s window, the protocol would enter a deadlock
since neither peer is allowed to send a <code>ReleaseWindow</code> packet.</p>
</li>
<li>
<p>If enough buffer space is available, a sender should avoid consuming the entire peer&#8217;s
buffer with one message. This would result in the sender sending a big message, the peer
processing that message and responding with a window release message, for which the sender had
to wait until it sends its next message. Instead, a sender should send packets of only half the peer&#8217;s
window size at a time. This enables the peer to process the packet, and send a window release
while the sender is sending the next message.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sesame_layer_secured"><a class="anchor" href="#_sesame_layer_secured"></a>SESAME layer Secured</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This protocol layer provides confidentiality and integrity by encrypting packets and appending
a MAC (Message Authentication Code). Since SESAME is geared towards embedded systems, and is
not intended to be as flexible as a protocol like TLS, for simplicity some very specific choices
are made regarding cryptographic schemes.</p>
</div>
<div class="paragraph">
<p>Encryption and authentication is done with <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197-upd1.pdf"><code>AES-128</code></a> in
<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode"><code>GCM</code></a> mode. <code>AES-128-GCM</code> requires a 128 bit
key and an 128 bit Initialisation Vector (IV). Both directions of communication require their own unique key/IV pair.</p>
</div>
<div class="paragraph">
<p>Each message is encrypted with <code>AES-128-GCM</code> with the key and IV as parameters. This results in
a cyphertext of size equal to the size of the message, plus a 16 byte MAC. Since in <code>GCM</code> IVs may
not be reused, the IV is incremented in a specific way to avoid using the same IV twice: After
each message, treat the IV as a 128-bit unsigned Big Endian number, and add 2<sup>64</sup> to it (discarding any overflow).
This way, the protocol can securely handle 2<sup>64</sup> messages each of size at most 2<sup>64</sup> before a
re-negotiation of keys is necessary.</p>
</div>
<div class="paragraph">
<p>Key establishment is not a responsiblity of the Secured layer; but care must be taken that
the same key/IV pair should not be reused for different sessions, since encrypting two messages
using the same key/IV pair will result in the XOR of the bit pattern of those two plaintext
messages to be equal to the XOR of the bit pattern of the two cyphertexts of those messages.</p>
</div>
<div class="paragraph">
<p>There is one exception to that rule: If the first message sent consists of at least 128 bits of
random data, then security is not compromised. The only information leaked is the XOR of two
times 128 bits of random data, from which an attacker still learns nothing. One possible scheme
of key establishment is therefore to hardcode the four Key and IV values for sending and receiving
on both hosts, and to choose random new Key/IV values right after initialization.</p>
</div>
<div class="paragraph">
<p>After each initialization of the lower protocol layers (after receiving the Init packet in the
Windowed layer), keys are reset to their default value, and key negotiation must start over
before other messages are sent.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_symmetric_key_establishment"><a class="anchor" href="#_symmetric_key_establishment"></a>Symmetric key establishment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many differrent ways exist to establish which keys the peers are going to use for the Secured layer;
which scheme to use heavily depends on the context in which SESAME is used. Two schemes are defined
in this specification.</p>
</div>
<div class="sect2">
<h3 id="_key_establishment_hardcoded_keys"><a class="anchor" href="#_key_establishment_hardcoded_keys"></a>Key Establishment: Hardcoded Keys</h3>
<div class="paragraph">
<p>Both peers can be configured with hardcoded keys when implementers are confident that attackers
can not extract those keys from the microcontrollers in which SESAME is implemented. A fixed key/IV
pair is chosen for sending data from peer A to peer B, and a fixed key/IV pair is chosen for sending
data from peer B to peer A.
However, as indicated before, care must be taken to not send two messages under the same key. Therefore,
before sending any other messages, each peer generates a new random key/IV pair, and uses the
<code>ActivateNewKeyMaterial</code> method of the <code>SymmetricKeyEstablishment</code> ECHO service (see appendix) to send
this pair to their peer. Upon reception of this method, a peer uses the presented key/IV pair for
encryption of subsequent messages that it sends.</p>
</div>
</div>
<div class="sect2">
<h3 id="_key_establishment_key_negotiation_with_diffie_hellman"><a class="anchor" href="#_key_establishment_key_negotiation_with_diffie_hellman"></a>Key Establishment: Key Negotiation with Diffie-Hellman</h3>
<div class="paragraph">
<p>In this scheme, a host does not need to be pre-programmed with the keys used by its peer. Instead,
the Diffie-Hellman scheme is used to have the two peers negotiate the required key/IV pairs. In order
to withstand man-in-the-middle attacks, the key exchange messages are signed, and the signature of
a received key exchange message is verified by the receiving party.</p>
</div>
<div class="paragraph">
<p>In order to verify the signature, a party must either have the certificate of its peer, or have a root
certificate by which the peer&#8217;s certificate&#8217;s validity is checked. In the latter case, a peer will
use the <code>PresentCertificate</code> method of the <code>DiffieHellmanKeyEstablishment</code> ECHO service to inform its
peer of a certificate to be used. A certificate is either presented in PEM or in DER format.
A party will verify each certificate presented in this way by
validating it against either one of the installed root certificates, or one of the earlier presented
certificates.</p>
</div>
<div class="paragraph">
<p>After any certificate exchange, a party will generate a new Elliptic Curve Diffie-Hellman public/private
key pair on the 256-bit curve defined by <a href="https://doi.org/10.6028/NIST.FIPS.186-5">FIPS 186-5</a> and
<a href="https://www.secg.org/sec1-v2.pdf">SEC1</a> (<code>SECP256R1</code>). It will then encode its public
key (which is a point of the elliptic curve) in the 65-byte uncompressed representation as defined in
SEC1 paragraph 2.3.3. It then uses <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf"><code>ECDSA</code></a>
on the same <code>SECP256R1</code> curve to compute the signature values <code>r</code> and <code>s</code>.
After computing the public/private key and the signatures, it sends the public key and the <code>r</code> and <code>s</code> values
using the <code>Exchange</code> method of the <code>DiffieHellmanKeyEstablishment</code> ECHO interface to its peer.</p>
</div>
<div class="paragraph">
<p>Upon reception, the peer uses the received <code>r</code> and <code>s</code> signature values to check the signature of the presented public key.
If this signature is correct, it computes the shared secret using its own private key and the peer&#8217;s public key
using the Diffie-Hellman scheme.
Key expansion is performed on the shared secret to generate enough material for the required key/IV pairs in this
way: <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90Ar1.pdf"><code>HMAC-DRBG-SHA256</code></a> is seeded
with the shared secret, and generates 4 times 256 bits of data. The first 256
bits of data is Key<sub>A</sub>, the next IV<sub>A</sub>, then Key<sub>B</sub>, then IV<sub>B</sub>. Both parties perform a lexicographical compare
of their Diffie-Hellman public keys. The party with public key that compares greater than the public key of its peer
uses Key<sub>A</sub> and IV<sub>A</sub> for sending data, the other party uses Key<sub>B</sub> and IV<sub>B</sub> for sending data.</p>
</div>
<div class="paragraph">
<p>When key exchange is done, both parties can start sending other ECHO data than the key exchange messages.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_echo_over_sesame"><a class="anchor" href="#_echo_over_sesame"></a>ECHO over SESAME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ECHO is used over SESAME by serializing ECHO messages, dividing those messages into a series
of chunks suitable to send over SESAME (so the maximum buffer size advertised by the peer must
be taken into account), and sending those chunks. On the receiving end, those chunks are reassembled,
and parsed as ECHO messages. Since ECHO is able to handle a continuous stream of data, multiple
ECHO messages being concatenated do not pose any difficulties.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendix_typical_sequence"><a class="anchor" href="#_appendix_typical_sequence"></a>Appendix: Typical sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This sequence diagram shows a typical sequence of the SESAME protocol being initialized and a message
being sent. The Secured layer is left out in this sequence.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="_images/diag-f5af5a4b5404143a9c1b8dfb93a66295bd65b6d3.svg" alt="Typical sequence">
</div>
<div class="title">Figure 5. Typical sequence</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendix_implementation_in_amp_embedded_infra_lib"><a class="anchor" href="#_appendix_implementation_in_amp_embedded_infra_lib"></a>Appendix: Implementation in amp-embedded-infra-lib</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The protocol layers and key establishment schemes defined here are implemented in amp-embedded-infra-lib.
Most of the classes are part of services/util.</p>
</div>
<div class="paragraph">
<p>The classes implementing the protocol layers are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>SesameCobs (services/util/SesameCobs.hpp)</p>
</li>
<li>
<p>SesameWindowed (services/util/SesameWindowed.hpp)</p>
</li>
<li>
<p>SesameSecured (services/utilSesameSecured.hpp)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>EchoOnSesame (services/util/EchoOnSesame.hpp) places ECHO on top of SESAME without security;
main_::EchoOnSesame&lt;max packet size&gt; (services/util/EchoInstantiation) instantiates EchoOnSesame,
SesameCobs and SesameWindowed to form a full ECHO on SESAME stack on top of a UART.</p>
</div>
<div class="paragraph">
<p>EchoOnSesameSymmetricKey (services/util/EchoOnSesameSymmetricKey.hpp) places ECHO on top of
SESAME with security, and implements the Hardcoded Keys scheme.</p>
</div>
<div class="paragraph">
<p>EchoOnSesameDiffieHellman (services/util/EchoOnSesameDiffieHellman.hpp) places ECHO on top of
SESAME with security and implements the Diffie-Hellman scheme. This class is instantiated with
one root certificate which is used to verify one certificate received by a peer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendix_sesamesecurity_proto"><a class="anchor" href="#_appendix_sesamesecurity_proto"></a>Appendix: SesameSecurity.proto</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-protobuf hljs" data-lang="protobuf">syntax = "proto3";

import "EchoAttributes.proto";

package sesame_security;

message SymmetricKeyMaterial
{
    bytes key = 1 [(bytes_size) = 16];
    bytes iv = 2 [(bytes_size) = 16];
}

message DiffieHellmanMaterial
{
    // This method uses an EC Diffie-Hellman exchange over the 256-bit curve defined by FIPS 186-4 and SEC1
    bytes publicKey = 1 [(bytes_size) = 65];
    // The signature will be computed over the publicKey using the sender's certificate, which uses EC DSA over the same curve as the EC DH operation
    bytes signatureR = 2 [(bytes_size) = 32];
    bytes signatureS = 3 [(bytes_size) = 32];
}

message Certificate
{
    // DER-encoded X.509 certificate, signed by a CA
    bytes certificate = 1 [(bytes_size) = 512];
}

service SymmetricKeyEstablishment
{
    option (service_id) = 3;

    rpc ActivateNewKeyMaterial(SymmetricKeyMaterial) returns (Nothing) { option (method_id) = 1; }
}

service DiffieHellmanKeyEstablishment
{
    option (service_id) = 4;

    rpc Exchange(DiffieHellmanMaterial) returns (Nothing) { option (method_id) = 1; }
    rpc PresentCertificate(Certificate) returns (Nothing) { option (method_id) = 2; }
}</code></pre>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>© Koninklijke Philips N.V., 2022. All rights reserved.</p>
</footer>

<script type="text/javascript" src="../../_/js/medium-zoom.min.js"></script>
<script type="text/javascript">
mediumZoom('.data-zoomable img', {
  margin: 50,
  background: '#FFFFFFA1',
})
</script>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async src="../../search-index.js"></script>
  </body>
</html>
